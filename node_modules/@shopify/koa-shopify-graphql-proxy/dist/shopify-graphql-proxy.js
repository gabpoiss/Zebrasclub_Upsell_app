"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var koa_better_http_proxy_1 = tslib_1.__importDefault(require("koa-better-http-proxy"));
exports.PROXY_BASE_PATH = '/graphql';
exports.GRAPHQL_PATH = '/admin/api/graphql.json';
function shopifyGraphQLProxy(proxyOptions) {
    return function shopifyGraphQLProxyMiddleware(ctx, next) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, session, shop, accessToken;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = ctx.session, session = _a === void 0 ? {} : _a;
                        shop = proxyOptions ? proxyOptions.shop : session.shop;
                        accessToken = proxyOptions
                            ? proxyOptions.password
                            : session.accessToken;
                        if (!(ctx.path !== exports.PROXY_BASE_PATH || ctx.method !== 'POST')) return [3 /*break*/, 2];
                        return [4 /*yield*/, next()];
                    case 1:
                        _b.sent();
                        return [2 /*return*/];
                    case 2:
                        if (accessToken == null || shop == null) {
                            ctx.throw(403, 'Unauthorized');
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, koa_better_http_proxy_1.default(shop, {
                                https: true,
                                parseReqBody: false,
                                // Setting request header here, not response. That's why we don't use ctx.set()
                                // proxy middleware will grab this request header
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-Shopify-Access-Token': accessToken,
                                },
                                proxyReqPathResolver: function () {
                                    return "https://" + shop + exports.GRAPHQL_PATH;
                                },
                            })(ctx, 
                            /*
                              We want this middleware to terminate, not fall through to the next in the chain,
                              but sadly it doesn't support not passing a `next` function. To get around this we
                              just pass our own dummy `next` that resolves immediately.
                            */
                            noop)];
                    case 3:
                        _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
}
exports.default = shopifyGraphQLProxy;
function noop() {
    return tslib_1.__awaiter(this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
        return [2 /*return*/];
    }); });
}
